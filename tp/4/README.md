# TP4 : SELinux

**Un mini-TP pour vous pr√©senter SELinux, comprendre √† quel endroit il s'ins√®re et essayer de vous faire sentir √† quel point le mod√®le qu'il propose est tr√®s granulaire et puissant.**

Cela vient √©videmment avec une (gross) charge de configuration suppl√©mentaire : need skillz. SELinux est un mod√®le complexe, on va se contenter de survoler l'une de ses principales fonctionnalit√©s ici : le *type enforcement*.

C'est le fait que toutes les ressources du syst√®me (user, port r√©seau, fichiers, processus) ont un *type* et que des r√®gles tr√®s granulaires d√©finissent quel type a le droit d'interagir avec quel autre type.

> SELinux s'en fout de la nature des entit√©s (il s'en fout qu'un programme essaie d'√©couter sur un port, ou un user acc√®s √† un fichier) il ne regarde que les *types* et les relations entre *types*.

![selinux conf help](./img/selinux.png)

> `setenforce 0` c'est pour d√©sactiver SELinux √©videmment ;)

## Sommaire

- [TP4 : SELinux](#tp4--selinux)
  - [Sommaire](#sommaire)
  - [0. Pr√©requis](#0-pr√©requis)
- [Part I : Premiers pas](#part-i--premiers-pas)
  - [0. Intro](#0-intro)
  - [1. Enabling SELinux](#1-enabling-selinux)
  - [2. The Z flag](#2-the-z-flag)
  - [3. Voir les r√®gles d√©finies](#3-voir-les-r√®gles-d√©finies)
- [Part II : Un peu de conf](#part-ii--un-peu-de-conf)
  - [1. Racine web](#1-racine-web)
  - [2. Port](#2-port)
  - [3. Your own policy](#3-your-own-policy)

## 0. Pr√©requis

‚ûú **Une seule VM Rocky**

- une seule fera le taff, on se concentre sur le fonctionnement de l'OS en lui-m√™me aujourd'hui encore

üåû **Installer NGINX**

- ce sera fait ! Ce sera pratique pour nos premiers exemples
- n'oubliez pas d'ouvrir le port firewall
- dans le compte-rendu : un `curl` depuis votre PC pour prouver que le site est dispo
```bash
# sur la VM
$ sudo firewall-cmd --add-port=80/tcp --permanent
$ sudo firewall-cmd --reload

# sur le PC
$ curl http://localhost:8888
```


üåû **Dans la conf NGINX par d√©faut**

- y'a une conf pour √©couter sur le port 80, et qui sert la page d'accueil par d√©faut
- mettez en √©vidence ces lignes (vous cherchez un bloc `server {}`)

```bash
# sur la VM
$ sudo cat /etc/nginx/nginx.conf
```

```nginx
server {
    listen       80 default_server;
    server_name  _;
    root         /usr/share/nginx/html;
    ...
}
```

> Profitez-en pour rep√©rer le chemin o√π est stock√© le site web par d√©faut, on va s'en servir dans la suite !

# Part I : Premiers pas

## 0. Intro

‚ûú **SELinux est un module du kernel**

Vous ne verrez pas de processus SELinux s'ex√©cuter, il est **dans** le kernel.

> Un "module", c'est un "plugin" ou un "mod" si vous pr√©f√©rez : un truc qui rajoute des fonctionnalit√©s. En l'occurrence, un module kernel : il rajoute des fonctionnalit√©s au kernel.

‚ûú **SELinux met en place du contr√¥le d'acc√®s**

D√®s qu'un programme essaie d'interagir avec l'OS (lecture ou √©criture d'un fichier, lancer un nouveau programme, utiliser le r√©seau, etc.), SELinux peut d√©cider si l'action est autoris√©e ou non.

SELinux s'ajoute √† la gestion de contr√¥le d'acc√®s habituelle (users + groupes + permissions rwx).

‚ûú **SELinux peut √™tre dans 3 √©tats :**

- **enforcing** : il est activ√©, il peut bloquer certaines actions, et il log toutes les actions qui enfreignent les r√®gles SELinux d√©finies
- **permissive** : il est activ√©, mais il log seulement toutes les actions qui enfreignent les r√®gles SELinux d√©finies (il ne bloque rien, il log juste)
- **disabled** : 'l√© po activ√©

‚ûú **SELinux est un syst√®me de labelling**

- on d√©finit un label (un "tag") sur **tous** les fichiers du syst√®me : on appelle √ßa un **contexte SELinux**
  - on peut le voir avec `ls -Z`
- les processus ont aussi un contexte
  - on peut le voir avec `ps -Z`
- on d√©finit un label sur un processus, un label sur un fichier, puis on √©crit une r√®gle pour indiquer que le contexte de notre processus est autoris√© √† interagir avec le contexte du fichier
- il faut donc absolument tout whitelister ! La moindre interaction.

‚ûú **Ce qui nous int√©resse principalement aujourd'hui dans le contexte SELinux, c'est le *type*.**

C'est le troisi√®me champ du contexte SELinux. C'est le truc qui se termine par `_t` par convention. 

C'est par exemple `httpd_sys_content_t` dans `system_u:object_r:httpd_sys_content_t:s0.`

> Pour un processus, le type, SELinux appelle aussi √ßa un *domain*.

## 1. Enabling SELinux

üåû **V√©rifier l'√©tat actuel de SELinux**

- √† votre dispo :
  - la commande `sestatus` affiche l'√©tat actuel de SELinux
  - la commande `setenforce` pour activer ou d√©sactiver temporairement SELinux
  - le fichier de conf : `/etc/selinux/config`
- v√©rifiez qu'il est bien actuellement activ√© et qu'il est bloquant
  - il doit √™tre mode **enforcing**
  - PAS EN MODE **permissive**
- v√©rifiez qu'il est configur√© pour √™tre activ√© d√®s le d√©marrage
- v√©rifiez qu'il est en mode *targeted* (pas le mode *mls* ou autre)
```bash	
$ sestatus
$ cat /etc/selinux/config
```
![alt text](image.png)
![alt text](image-1.png)


## 2. The Z flag

‚ûú Beaucoup de commandes usuelles sont d√©sormais pourvues de l'option `-Z` qui permet d'afficher les labels SELinux.

```bash
# voir les labels sur des fichiers/dossiers/etc.
$ ls -al -Z

# voir les labels sur des users
$ id -Z

# voir les labels des processus en cours d'ex√©cution
$ ps -ef -Z

# voir les labels des ports TCP et UDP en √©coute
$ ss -lnptu -Z
```

üåû **D√©terminer le *type* SELinux de...**

- l'utilisateur NGINX
- le fichier de conf de NGINX
- le programme NGINX sur le disque
- le dossier dans lequel se trouve le fichier HTML par d√©faut
- le fichier HTML par d√©faut
- le processus NGINX en cours d'ex√©cution
- le port TCP utilis√© par NGINX pour √©couter

```bash	
# l'utilisateur NGINX
su 
sudo -u nginx id -Z
# unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023

# le fichier de conf de NGINX
ls -al -Z /etc/nginx/nginx.conf
# -rw-r--r--. 1 root root system_u:object_r:httpd_config_t:s0 2334 Nov  8 17:43 /etc/nginx/nginx.conf

# le programme NGINX sur le disque
ls -al -Z /usr/sbin/nginx
# -rwxr-xr-x. 1 root root system_u:object_r:httpd_exec_t:s0 1329232 Nov  8 17:44 /usr/sbin/nginx

# le dossier dans lequel se trouve le fichier HTML par d√©faut
ls -al -Z /usr/share/nginx/html
-rw-r--r--. 1 root root system_u:object_r:httpd_config_t:s0 2334 Nov  8 17:43 /etc/nginx/nginx.conf
[ah4@localhost ~]$ ls -al -Z /usr/sbin/nginx
-rwxr-xr-x. 1 root root system_u:object_r:httpd_exec_t:s0 1329232 Nov  8 17:44 /usr/sbin/nginx
[ah4@localhost ~]$ ls -al -Z /usr/share/nginx/html
total 12
# drwxr-xr-x. 3 root root system_u:object_r:httpd_sys_content_t:s0  143 Feb 28 15:04 .
# drwxr-xr-x. 4 root root system_u:object_r:usr_t:s0                 33 Feb 28 15:04 ..
# -rw-r--r--. 1 root root system_u:object_r:httpd_sys_content_t:s0 3332 Nov  8 17:41 404.html
# -rw-r--r--. 1 root root system_u:object_r:httpd_sys_content_t:s0 3404 Nov  8 17:41 50x.html
# drwxr-xr-x. 2 root root system_u:object_r:httpd_sys_content_t:s0   27 Feb 28 15:04 icons
# lrwxrwxrwx. 1 root root system_u:object_r:httpd_sys_content_t:s0   25 Nov  8 17:44 index.html -> ../../testpage/index.html
# -rw-r--r--. 1 root root system_u:object_r:httpd_sys_content_t:s0  368 Nov  8 17:41 nginx-logo.png
# lrwxrwxrwx. 1 root root system_u:object_r:httpd_sys_content_t:s0   14 Nov  8 17:44 poweredby.png -> nginx-logo.png
# lrwxrwxrwx. 1 root root system_u:object_r:httpd_sys_content_t:s0   37 Nov  8 17:44 system_noindex_logo.png -> ../../pixmaps/system-noindex-logo.png

# le fichier HTML par d√©faut
ls -al -Z /usr/share/nginx/html/index.html
# lrwxrwxrwx. 1 root root system_u:object_r:httpd_sys_content_t:s0 25 Nov  8 17:44 /usr/share/nginx/html/index.html -> ../../testpage/index.html

# le processus NGINX en cours d'ex√©cution
ps -efZ | grep nginx
# system_u:system_r:httpd_t:s0    root       11264       1  0 15:16 ?        00:00:00 nginx: master process /usr/sbin/nginx

# le port TCP utilis√© par NGINX pour √©couter
sudo ss -lnptu | grep nginx
# tcp    LISTEN     0      128    *:80                   *:*                   tcp   LISTEN 0      511          0.0.0.0:80        0.0.0.0:*    users:(("nginx",pid=11268,proc_ctx=system_u:system_r:httpd_t:s0,fd=6),("nginx",pid=11267,proc_ctx=system_u:system_r:httpd_t:s0,fd=6),("nginx",pid=11266,proc_ctx=system_u:system_r:httpd_t:s0,fd=6),("nginx",pid=11265,proc_ctx=system_u:system_r:httpd_t:s0,fd=6),("nginx",pid=11264,proc_ctx=system_u:system_r:httpd_t:s0,fd=6))
# tcp   LISTEN 0      511             [::]:80           [::]:*    users:(("nginx",pid=11268,proc_ctx=system_u:system_r:httpd_t:s0,fd=7),("nginx",pid=11267,proc_ctx=system_u:system_r:httpd_t:s0,fd=7),("nginx",pid=11266,proc_ctx=system_u:system_r:httpd_t:s0,fd=7),("nginx",pid=11265,proc_ctx=system_u:system_r:httpd_t:s0,fd=7),("nginx",pid=11264,proc_ctx=system_u:system_r:httpd_t:s0,fd=7))
```

> Vraiment, on se concentre que sur le *type* : le troisi√®me champ du contexte, qui se termine par `_t` par convention. Le reste d'interf√©rera du contexte pas dans notre TP.

## 3. Voir les r√®gles d√©finies

Pour voir des r√®gles, on utilise g√©n√©ralement `sesearch`.

Utilisation typique :

```bash
sesearch --allow --source un_truc_t --target un_truc_t --class une_classe

# par exedmple
sesearch --allow --source httpd_t --target httpd_t --class file
```

üåû **Afficher les r√®gles li√©es √† NGINX**

- afficher les r√®gles que le type SELinux du processus NGINX...
- ...a sur le type SELinux du fichier HTML

```bash
sesearch --allow --source httpd_t --target httpd_sys_content_t --class file
```


> Encore une fois, on se concentre essentiellement sur les *types* dans ce TP. Et SELinux s'en fout des fichiers/processus ou quoi, il regarde que les *types*. Donc je vais beaucoup r√©p√©ter "*type*" dans ce TP o√®.

# Part II : Un peu de conf

On va √† chaque fois proc√©der de fa√ßon it√©rative :

- modifier la conf
- red√©marrer le service
- constater le *sproutch*
- afficher les logs SELinux
- trouver la ligne de log qui nous dit exactement ce qui a √©t√© bloqu√©

## 1. Racine web

Vous l'avez normalement rep√©r√© en intro, NGINX sert une page d'accueil par d√©faut. Elle est dans `/usr/share/nginx/html` (comme indiqu√© dans le fichier de conf).

On va d√©placer √ßa dans `/var/www/meow/`.

**C'est un bon pr√©texte pour voir l'interaction entre un processus et un fichier lorsque SELinux est activ√©.**

üåû **Cr√©ez-moi tout √ßa**

- un dossier `/var/www/meow/` qui appartient au user qui lance NGINX
- ontient un fichier `index.html` (contenu de votre choix) qui appartient au user qui lance NGINX
- droits de lecture sur le dossier/le fichier pour le propri√©taire

üåû **Modifier la conf NGINX**

- pour que le site servi sur le port 80 ne soit plus celui de `/usr/share/nginx/html` mais celui qui est dans `/var/www/meow/` (une seule ligne de conf √† modifier)
- (re)d√©marrez le service  `nginx`
- visitez la page web et constater le sproutch (403)

![403](./img/403.png)

üåû **Logs !**

- rep√©rez la ligne de log qui montre l'interaction qui a √©t√© bloqu√©e
- le fichier de log c'est `/var/log/audit/audit.log`
- vous cherchez une ligne qui contient le mot `avc` (c'est le nom des blocages SELinux)
- et qui contient le *type* du processus `nginx` que vous avez rep√©r√© plus t√¥t

> La ligne doit explicitement mentionner un blocage pour la lecture d'un fichier.

üåû **Etat des lieux**

- afficher le contexte SELinux de `/usr/share/nginx/html` (oui tu l'as d√©j√† fait, je sais)
- afficher le contexte SELinux de `/var/www/meow`
- constater qu'ils sont diff√©rents, et que √ßa sent le vinaigre

> Il faudrait que notre processus NGINX puisse acc√©der √† ce dossier. Plein de fa√ßons de faire : on pourrait par exemple cr√©er un nouveau type `meow_t`, l'attribuer √† notre fichier `index.html` et autoriser le *type* du processus NGINX √† le lire. On va rien faire de tout √ßa :D

üåû **Conf simpliste**

- on va se contenter d'appliquer √† notre `/var/www/meow/` la m√™me conf que le dossier de base
- je vous file la commande :

```bash
# copier r√©cursivement les contextes SELinux d'un dossier vers un autre
chcon -R --reference /usr/share/nginx/html /var/www/meow
```

üåû **Constater le changement**

- votre dossier `/var/www/meow` et son contenu devraient avoir un nouveau contexte SELinux

üåû **Red√©marrez NGINX**

- visitez le site web
- no sproutch ?

## 2. Port

Idem, toujours au m√™me endroit dans la conf, vous l'avez rep√©r√© en intro, NGINX √©coute par d√©faut sur le port 80.

On va changer √ßa pour un autre port non-conventionnel : 8888/tcp.

**C'est un bon pr√©texte pour voir l'interaction entre un processus et un port TCP lorsque SELinux est activ√©.**

üåû **Modifier la conf de NGINX**

- il doit √©couter sur le port 8888/tcp
- n'oubliez pas d'ouvrir ce port dans le firewall
- r√©d√©marrez NGINX apr√®s avoir modifi√© la conf
- constater un sproutch imm√©diat au red√©marrages

üåû **Logs logs logs !**

- rep√©rez la ligne de log qui montre l'interaction qui a √©t√© bloqu√©e
- vous cherchez toujours une ligne qui contient le mot `avc` (c'est le nom des blocages SELinux)
- et qui contient le *type* du processus `nginx` que vous avez rep√©r√© plus t√¥t
- et qui mentionne explicitement un blocage sur le port TCP (tcp socket) 8888

‚ûú **On va proc√©der diff√©remment pour le port**

- on va continuer √† r√©utiliser la conf existante
- il existe d√©j√† une liste de ports qui portent le type `http_port_t` par d√©faut
- le type de NGINX a le droit d'√©couter sur les ports `http_port_t` par d√©faut

üåû **Marquons le port `8888/tcp` avec le type `http_port_t`**

- la commande :

```bash
semanage port -a -t http_port_t -p tcp 8888
```

- prouvez que votre port est bien dans la liste des `http_port_t` avec

```bash
semanage port -l
```

üåû **Red√©marrez NGINX**

- no sproutch ?

## 3. Your own policy

Actuellement, SELinux a une *policy* charg√©e : un ensemble de r√®gles (des kilotonnes d√©j√† sur une install de base de Rocky) qui d√©termine ce qui est autoris√© pour √©norm√©ment d'applications qu'on peut installer via les paquets.

C'est modulaire comme truc : on √©crit un fichier de conf SELinux par programme, et tout est compil√© en une *policy* unique.

Vous pouvez lister les modules charg√©s dans la policy actuelle avec :

```bash
semodule -l
```

Bon, et on peut nous-m√™mes √©crire un fichier de r√®gle SELinux, et en faire un module, et l'ajouter √† la *policy*. Id√©al si on a un super service fait maison, et qu'on souhaite ajouter une policy pour lui !

Genre j'sais pas, UNE CALCULATRICE RESEAU.

‚ûú **R√©cup√©rez la calculatrice r√©seau**

- le fichier de code + votre `.service`
- avec SELinux activ√©, le service ne devrait pas d√©marrer

‚ûú **L√† encore on va rester simple, et utiliser une technique diff√©rente**

- quand une action est bloqu√©e, √ßa produit une ligne de log dans `/var/log/audit.audit.log` qui explique pr√©cis√©ment ce qui a √©t√© bloqu√© (on peut utiliser la commande `ausearch` pour chercher facilement avec options cools dans ce fichier)
- on peut g√©n√©rer une conf qui autorise cette action, √† partir de la ligne de log, avec la commande `audit2allow`
- je recommande des trucs du genre `sudo ausearch -m AVC -ts recent | tail -n200 | sudo audit2allow -a -m meow` pour g√©n√©rer automatiquement un module pour une policy SELinux :
  - n'affiche que les logs r√©cents
  - r√©cup√®re les 200 derni√®res lignes
  - produit la conf avec `audit2allow`
  - le module sera nomm√© `meow`

> On va pas faire du die&retry : lancer le truc, g√©n√©rer une ligne de nouvelle conf, relancer, √ßa crash encore, on reg√©n√®re une ligne, et ainsi de suite. Le mode permissive de SELinux est l√† pour √ßa : il g√©n√®re tous les logs, sans nous bloquer.

![audit2allow](./img/audit2allow.png)

üåû **Passer temporairement SELinux en mode *permissive***

- avec un `sudo setenforce 0`
- v√©rifier avec un `sestatus`

üåû **Lancer l'application**

- avec un `sudo systemctl restart calculatrice`
- elle devrait fonctionner

üåû **Observer les logs**

- vous devriez voir des trucs bloqu√©s en relation avec notre service
- avec un :

```bash
sudo ausearch -m AVC -ts recent | tail -n200
```

üåû **Observer la conf autog√©n√©r√©e**

- m√™me commande, mais on rajoute `audit2allow`, go faire : 

```bash
sudo ausearch -m AVC -ts recent | tail -n200 | sudo audit2allow -a -m meow
```

üåû **Stocker la conf g√©n√©r√©e**

- on redirige le tout dans un fichier qui porte l'extension `.te` par convention
- go :

```bash
# allez dans votre homedir
cd

# g√©n√©rez le fichier de conf pour un nouveau module SELinux
sudo ausearch -m AVC -ts recent | tail -n200 | sudo audit2allow -a -m meow > meow.te
```

üåû **Appliquer la conf**

- on va compiler ce nouveau module SELinux `meow`
- et on pourra ensuite le charger dans notre policy SELinux actuelle
- suivez le guide :

```bash
# toujours dans le m√™me dossier, avec le fichier meow.te

# on compile le module en un .pp
sudo checkmodule -M -m -o meow.mod meow.te
sudo semodule_package -o meow.pp -m meow.mod

# chargement du module dans notre policy actuelle
# √ßa peut prendre un peu de temps
sudo semodule -i meow.pp
```

üåû **Repasser SELinux en mode *enforcing***

- avec un `sudo setenforce 1`
- v√©rifier avec `sestatus`

üåû **Red√©marrer le service**

- shoud work !

üåû **Observer le nouveau module charg√©**

- lister les modules SELinux en cours de fonctionnement
- et `grep meow` !

![shell_as_root](./img/shell_as_root.png)
